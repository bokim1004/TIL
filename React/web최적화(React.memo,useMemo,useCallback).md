### React에서의 최적화

최적화는 `불필요한 계산을 최소화`하는 것이다.

웹페이지가 하나 만들어질 때, DOM Tree구성, 레이아웃잡기, 페인팅하기 등의 다양한 작업이 이루어진다.
업데이트 상황이 오면 컴포넌트를 다시 렌더링하고, 그 때 레이아웃 및 페인팅 과정을 또 계산해야 하는 경우가 잦다.

그래서 React의 성능을 점검할 때는 컴포넌트 자체의 리렌더링이 불필요하게 반복되고 있지 않은지, 내부 로직이 쓸데없이 다시 만들어지거나 복잡한 계산을 반복하고 있지 않은지 생각해야 한다.


쓸데없이 같은 계산을 반복하지 않게 할 수 있는 방법은 `결과를 기억`하는 것이다.

흔히 알고 있는 Caching을 떠올려보자. 메모리에서 어떤 값을 가져오고자 할 때, 맨날 메모리나 디스크에서 가져오기엔 시간이 오래걸릴테니 최근에 접근한 값이나 자주 사용한 값을 캐시에 저장해두고 사용한다.

React에서의 최적화에서는 `메모이제이션`이라고 부르는 개념을 활용한다.
이 메모이제이션은 캐싱의 일종이라 볼 수 있다. 메모이제이션은 특정 함수가 동작되고 반환된 그 결과물을 캐싱하는 경우를 말한다.

#### React.memo

컴포넌트 자체를 메모이제이션 한다.
React.memo(MemoTest)로 한번 감싸주면 App이 리렌더링되더라도 그 안에 있던 MemoTest컴포넌트는 딱히 리렌더링되지 않는다.
React.memo를 사용하면 어떤 컴포넌트를 어떤 Props와 함께 불렀는지 기록하고, 같은 경우에는 이전에 기록해둔 컴포넌트 결과값을 반환한다. Memoization방식이다.

`React.memo는 한 컴포넌트를 같은 프로퍼티로 리렌더링하는 경우가 빈번할 때 사용해야한다.` 무조건 사용한다고 좋은 것이 아니다.
만약 프로퍼티가 계속 변경되는 컴포넌트를 React.memo로 해봤자 괜히 프로퍼티를 비교하는 과정만 추가되지 실속은 없다.
그리고 Memoization을 위해 계속 기록을 해야하므로 매번 만들어진 컴포넌트들을 기록하는 공간만 조금씩 더 차지하게 될 것이다.


#### useMemo
컴포넌트에 적용할 수 있는 React.memo와 달리, 복잡한 계산의 결과 값을 Memoization해 최적화하기 위한 `useMemo`훅이 있다. 
```ts
const items = useState([]);
const convertedItems = useMemo(
items.map(item => {
...item,
additionalData:somethingHardCalc(item)
},[items]
)
}
```
useMemo에는 2개의 인자가 들어간다.
첫번 째는 우리가 구동하기 원하는 함수 하나. 위에선 items에 들어있는 데이터를 변환해주는 함수가 있다, somethingHardCalc는 복잡한 계산의 함수
그리고 두 번째 인자는 useEffect를 사용할 때처럼 deps를 설정할 수 있다. items가 변경될 떄만 첫번 째 인자에 들어있는 함수를 동작시킨다고 볼 수 있다.

useMemo도 memoization을 하는데, useMemo자체에 대해 Memoization이 일어난다.

useMemo라는 함수와 그 프로퍼티인 items값이 뭐가 들어오는지 확인하고 처음 보는 값이면 첫번째 인자의 함수를 구동해 그 값을 기록한다.
만약 이전에 본 값이면 계산은 생략하고 전에 기록해둔 값을 돌려주는 방식으로 복잡한 계산을 줄일 수 있다.

#### React.memo와 useMemo의 차이는 어디에 활용되는가이다.

React.memo는 컴포넌트를 받아 컴포넌트를 반환한다.
useMemo는 값을 계산하는 과정을 최적화해 값을 반환받는다.

useMemo로 전달된 함수는 렌더링 중에 실행된다. 통상적으로 렌더링 중에는 하지 않는 것을 이 함수내에서 하지않는게 좋다.


#### useMemo와 useCallback의 차이

useMemo는 함수 호출 이후의 return값이 memoized된다.
- 메모이제이션된 값을 반환함
- 두 번째 파라미터인 배열요소가 변경될 때마다 첫번째 인자의 callback함수를 다시 생성하는 방식

useCallback은 메모이제이션된 함수를 반환한다.
두번째인자인 배열요소가 변경될 때마다 새로운 함수가 생성된다.

참고 :https://medium.com/hcleedev/web-%EC%B5%9C%EC%A0%81%ED%99%94%EC%99%80-react-memo-usememo-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-4324a237a039


