### HTTP란?

HTTP는 Hyper Text Transfer Protocol의 두문자어로 `인터넷에서 데이터를 주고받을 수 있는 프로토콜`이다.
프로토콜은 규칙이라고 생각하면 된다. 이렇게 규칙을 정해두었기에 모든 프로그램이 이 규칙에 맞춰 개발해서 서로 정보를 교환할 수 있게 된 것이다.

클라이언트와 서버들은 개별적인 메시지 교환에 의해 통신한다. 보통 브라우저인 클라이언트에 의해 전송되는 메시지를 요청(request)이라고 부르며,
그에 대해 서버에서 응답으로 전송되는 메시지를 응답(response)이라고 부른다

HTTP의 확장성 덕분에, 오늘날 하이퍼텍스트 문서뿐만 아니라 이미지와 비디오 혹은 HTML 폼 결과같은 내용을 서버로 POST하기 위해서도 사용된다.


### HTTP 특징
**- HTTP 메시지는 HTTP서버와 HTTP클라이언트에 의해 해석이 된다.**

**- TCP/IP를 이용하는 응용 프로토콜이다. (컴퓨터와 컴퓨터간에 데이터를 전송할 수 있도록하는 장치로 인터넷이라는 거대한 통신망을 통해 원하는 정보(데이터)를 주고 받는 기능을 이용하는 응용프로토콜)**

**- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다. (이런 단점을 해결하기 위해 cookie,session이 등장함)**
클라이언트와 서버가 연결되어있지 않다. 왜? 리소스때문이다. 계속해서 연결되어있다는 말은 계속해서 리소스가 들어가기 때문이다.
그럼 연결되지 않고 어떻게 통신을 할까?
클라이언트가 어떤 데이터를 요청하면 서버는 응답을 하고 한번 맺었던 연결을 끊어버린다.

**- HTTP는 연결을 유지하지 않는 프로토콜이기에 `요청/ 응답 방식`으로 동작한다.**

**- 무상태Stateless 특징을 가지고 있다.**
말 그대로 상태를 가지고 있지 않다. 구체적으로 말하면 서버가 클라리언트의 상태를 가지고 있지 않다.
왜 상태를 가지고 있지 않은가? 비용(리소스)을 줄이기 위해서다.
무상태 방식은 요청을 할 때 모든 정보를 각 서버에게 전달해야 하기에 요청이 복잡해진다는 단점이 있다.
반면에 요청을 한번에 주기에 많은 서버를 둬도 큰 부담이 안된다는 장점이 있다.
stateless는 서버의 확장성에 용이하다.

`상태를 기억하는 방법 1) 쿠키`
서비스를 운영하려면 서버가 클라이언트를 기억해야할 경우가 많다. HTTP는 이러한 문제점을 해결하기 위해 브라우저단에서 쿠키라는 것을 저장하여 서버가 클라이언트를 식별할 수 있도록 한다.

`상태를 기억하는 방법 2) 세션`
쿠키는 사용자 정보가 브라우저에 저장되기에 공격자로부터 위변조의 가능성이 높아 보안에 취약하다.
이와 달리 세션은 브라우저가 아닌 서버단에서 사용자 정보를 저장하는 구조다.
따라서 쿠키보다는 안전하다.
그런데 세션 정보다 중간에 탈취당할 수 있기에 보안에 완벽하다고 볼 수 없다.
또한 세션을 사용하면 서버에 사용자 정보를 저장하므로 서버의 메모리를 차지하게 되고, 만약 동시 접속자 수가 많은 서비스일 경우에는 서버 과부화의 원인이 된다.


### HTTP Header, body 차이

HTTP요청과 응답의 구조는 서로 닮았고 구조는 다음과 같다.

1) 시작줄에는 실행되어야할 요청 또는 요청 수행에 대한 성공 또는 실패가 기록되어 있다. 이 줄은 항상 한 줄로 끝난다. <br/>
2) 옵션으로 HTTP 헤더 세트가 들어간다. 여기에는 요청에 대한 설명 혹은 메시지 본문에 대한 설명이 들어간다.<br/>
3) 요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈줄이 삽입된다.<br/>
4) 요청에 관련된 내용이 옵션으로 들어가거나, 응답과 관련된 문서가 들어간다. 본문의 존재 유무 및 크기는 첫 줄과 HTTP 헤더에 명시된다.

<p align="center"> <img src="https://velog.velcdn.com/images/chloeee/post/39e286fd-7f69-45cd-bf93-b00dc9a5fb8b/image.png"  width="800px"  alt="img"/> </p>

HTTP 메시지의 시작줄과 HTTP 헤더를 묶어서  `요청 헤드(Head)`라고 부르며, 반대로 HTTP 메시지의 페이로드는 `본문 (body)`라고 한다.

#### HTTP 요청

`시작줄` : HTTP요청은 서버가 특정 동작을 취하게끔 만들기 위해 클라이언트에서 전송하는 메시지이다.
시작줄은 3가지 요소로 되어있다. <br/>
1. HTTP메소드로 (Get,Put,Post)등을 사용해 서버가 수행해야할 동작을 나타낸다.<br/>
2. 두번째로 오는 요청 타켓을 주로 URL,프로토콜,포트,도메인의 절대 경로로 나타낼 수도 있으며 이들은 요청 컨텍스트에 의해 특정지어진다. 
3. 마지막으로 HTTP 버전이 들어간다. 메시지의 남은 구조를 결정하기에 응답메시지에서 써야할 HTTP 버전을 알려주는 역할을 한다.
<br/>

`헤더` : 요청에 들어가는 HTTP 헤더는 HTTP 헤더의 기본 구조를 따른다. 대소문자 구분없는 문자열 다음에 콜론(:)이 붙으며 그 뒤에 오는 값은 헤더에 따라 달라진다.<br/>
헤더는 값까지 포함해 한 줄로 구성되지만 꽤 길어질 수 있다.
다양한 종류의 요청 헤더가 있는데, 이들은 다음과 같이 몇몇 그룹으로 나눌 수 있다. <br/>
- General 헤더: Via와 같은 헤더는 메시지 전체에 적용된다. <br/>
- Request 헤더: User-Agent (en-US), Accept-Type와 같은 헤더는 요청의 내용을 좀 더 구체화 시키고(Accept-Language), 컨텍스를 제공하기도 하며(Referer), 조건에 따른 제약 사항을 가하기도 하면서(If-None) 요청 내용을 수정한다 <br/>
- Entity 헤더: Content-Length와 같은 헤더는 요청 본문에 적용된다. 당연히 요청 내에 본문이 없는 경우 entity 헤더는 전송되지 않는다.

<p align="center"> <img src="https://velog.velcdn.com/images/chloeee/post/3d91807b-dd81-4f92-a078-33a0000d2506/image.png"  width="800px"  alt="img"/> </p>

`본문(바디)` : 본문은 요청의 마지막 부분에 들어간다. 모든 요청에 본문이 들어가지 않는다. get,head,delete처럼 리소스를 가져오는 요청은 보통 본문이 필요 없다. 일부 요청은 업데이트를 하기 위해 서버에 데이터를 전송한다. 보통 post일 경우에 그렇다. <br/>
넓게 보면 본문은 두가지 종류로 나뉜다. <br/>
단일-리소스 본문(single-resource bodies): 헤더 두 개(Content-Type와 Content-Length)로 정의된 단일 파일로 구성됩니다.
다중-리소스 본문(multiple-resource bodies): 멀티파트 본문으로 구성되는 다중 리소스 본문에서는 파트마다 다른 정보를 지니게 됩니다. 보통 HTML 폼 (en-US)과 관련이 있습니다.

#### HTTP 응답

`상태 줄` : HTTP 응답의 시작 줄은 상태 줄이라고 불리며, 다음과 같은 정보를 가지고 있다.

1. 프로토콜 버전: 보통 HTTP/1.1 <br/>
2. 상태 코드 : 요청의 성공여부를 나타낸다. 200, 404, 302같은 코드 <br/>
3. 상태 텍스트 : 짧고 간결하게 상태 코드에 대한 설명을 글로 나타내어 사람들이 HTTP 메시지를 이해할 때 도움이 된다. <br/>

상태 줄은 일반적으로 `HTTP/1.1 404 Not Found`같이 생겼다.

`헤더` : 응답에 들어가는 HTTP헤더는 다른 헤더와 동일하다. <br/>

다양한 종류의 응답 헤더가 있는데, 이들은 다음과 같이 몇몇 그룹으로 나눌 수 있다.
<br/>

General 헤더: Via와 같은 헤더는 메시지 전체에 적용된다.  <br/>
Response 헤더: Vary와 Accept-Ranges와 같은 헤더는 상태 줄에 미처 들어가지 못했던 서버에 대한 추가 정보를 제공한다. <br/>
Entity 헤더: Content-Length와 같은 헤더는 요청 본문에 적용됩니다. 당연히 요청 내에 본문이 없는 경우 entity 헤더는 전송되지 않는다. <br/>

<p align="center"> <img src="https://velog.velcdn.com/images/chloeee/post/87ed2d17-9009-4739-845f-51f2e7740d20/image.png"  width="800px"  alt="img"/> </p>

`본문` : 응답의 마지막 부분에 들어간다. 모든 응답에 본문이 들어가지 않는다. 201,204같은 상태 코드를 가진 응답에는 본문이 보통 없다. <br/>

이미 길이가 알려진 단일 파일로 구성된 단일-리소스 본문: 헤더 두개(Content-Type와 Content-Length)로 정의한다. <br/>
길이를 모르는 단일 파일로 구성된 단일-리소스 본문: Transfer-Encoding가 chunked로 설정되어 있으며, 파일은 청크로 나뉘어 인코딩 되어 있다. <br/>
서로 다른 정보를 담고 있는 멀티파트로 이루어진 다중 리소스 본문: 이 경우는 상대적으로 위의 두 경우에 비해 보기 힘들다. <br/>
