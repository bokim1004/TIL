## 호이스팅이란

`호이스팅이란`: 코드를 실행하기 전에 선언된 변수 및 함수를 해당 스코프의 맨 위로 끌어당겨 최상단에 선언하는 것을 말한다.

- 자바스크립트 parser가 함수 실행 전 해당 함수를 한 번 훑는다.
- 함수 안에 존재하는 변수/함수 선언에 대한 정보를 기억하고 있다가 실행시킨다.
- 유효범위: 함수 블록{}안에서 유효하다.
  즉, 함수 내에서 아래쪽에 존재하는 내용중 필요한 값들을 끌어올리는 것이다.
  실제 메모리에는 변화가 없다. 실제로 코드가 끌어올려지는 것은 아니고 자바스크립트 parser 내부적으로 끌어올려서 처리하는 것이다.
  
  javascript는 함수의 코드를 실행하기 전에 함수 선언에 대한 메모리부터 할당한다.
  덕분에 함수를 호출하는 코드를 함수 선언보다 앞서 배치할 수 있다.
 ```js
 function catName(name) {
  console.log("제 고양이의 이름은 " + name + "입니다");
}

catName("호랑이");

/*
결과: "제 고양이의 이름은 호랑이입니다"
*/
 ```
 
 함수 호출이 함수 자체보다 앞서 존재하지만, 이 코드 역시 동작한다.
 ```js
 catName("클로이");

function catName(name) {
  console.log("제 고양이의 이름은 " + name + "입니다");
}

/*
결과: "제 고양이의 이름은 클로이입니다"
*/
 ```
 
 ### 선언만 호이스팅 대상
 
 javascript는 초기화를 제외한 선언만 호이스팅한다.
 예를 들어
 
 ```js
 console.log(num); // 호이스팅한 var 선언으로 인해 undefined 출력
var num; // 선언
num = 6; // 초기화
 ```
 
 선언없이 초기화만 존재하면, 호이스팅은 없고 변수를 읽으려는 시도에서 ReferenceError예외가 발생한다.
 ```js
 console.log(num); // ReferenceError
num = 6; // 초기화
 ```
 
 ### let과 const 호이스팅
 
 let과 const로 선언한 변수도 호이스팅 대상이지만, var와 달리 호이스팅시 undefined로 변수를 초기화하지 않는다.
 let과 const는 선언 이후에 초기화 과정이 이루어진다.
 
 ```js
 // 아직 foo가 선언은 되었지만 초기화가 진행되지 않았기 때문에 참조 불가능
console.log(foo); // ReferenceError: Cannot access 'foo' before initialization

// foo가 undefined로 초기화가 되었다.
let foo;
console.log(foo); // undefined

// foo에 값이 할당되었다.
foo = 5;
console.log(foo); // 5
 ```
 
 let의 경우 선언단계와 초기화 단계가 분리되어 있고 그 사이에 TDZ가 존재한다.즉 Temporal Dead Zone은 호이스팅된 선언부와 초기화 및 할당시점 사이에 시간상 사각지대를 말한다. 이 TDZ에 접근하면 Reference Error가 발생하게 된다.
 const의 경우 let과 달리 선언단계와 초기화 단계가 동시에 실행된다. 하지만 그전에 TDZ가 생성되어 TDZ에 접근할 경우 역시 Reference Error가 발생한다.
 
 var는 let,const와 달리 TDZ가 존재하지 않는다. var는 선언단계와 초기화 단계가 동시에 진행되며 선언과 동시에 undefined로 초기화된다.

### 호이스팅은 개발자가 이해하기 어려운데 왜 만들었을까? 일어나는 이유가 뭘까?

함수 호이스팅이 발생하는 원인은 자바스크립트 변수 생성과 초기화(선언과 할당)가 분리되어 진행되기 때문이다.

이런 호이스팅을 적용하는 이유는 필요한 메모리를 먼저 잡아놓기 위해서가 아닐까?
호이스팅은 지양하는 것이 좋다. 코드의 가독성과 유지보수를 위해 호이스팅이 일어나지 않도록 한다.
변수,함수명이 같은 상태로 호이스팅이 발생하면 변수가 함수 값을 덮어쓰는 단점도 있다.
let,const를 사용하고 var는 쓰지 않는 것이 좋다.
